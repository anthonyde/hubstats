// Generated by CoffeeScript 1.4.0
(function() {
  "use strict";

  var BASE_URL;

  BASE_URL = "https://github.com";

  this.Network = (function() {
    var queryJSONP, queryNetworkData, queryNetworkMeta;

    queryJSONP = function(url, success, error) {
      $.ajax(url, {
        cache: true,
        dataType: "jsonp",
        error: function() {
          return error();
        },
        success: function(data) {
          return success(data);
        },
        timeout: 5000
      });
    };

    queryNetworkMeta = function(login, repo, success, error) {
      var url;
      url = "" + BASE_URL + "/" + login + "/" + repo + "/network_meta";
      queryJSONP(url, success, error);
    };

    queryNetworkData = function(login, repo, nethash, start, end, success, error) {
      var url;
      url = "" + BASE_URL + "/" + login + "/" + repo + "/network_data_chunk?nethash=" + nethash + "&start=" + start + "&end=" + end;
      queryJSONP(url, success, error);
    };

    function Network(login, repo) {
      this.login = login;
      this.repo = repo;
      this.error = null;
      this.status = null;
      this.nethash = null;
      this.commits = null;
    }

    Network.prototype.onError = function(x) {
      if (!arguments.length) {
        return this.error;
      } else {
        this.error = x;
        return this;
      }
    };

    Network.prototype.onStatus = function(x) {
      if (!arguments.length) {
        return this.status;
      } else {
        this.status = x;
        return this;
      }
    };

    Network.prototype.getMeta = function(callback) {
      var sinkMeta,
        _this = this;
      sinkMeta = function(meta) {
        if (typeof _this.status === "function") {
          _this.status({
            type: "meta"
          });
        }
        if (_this.nethash !== meta.nethash) {
          _this.nethash = meta.nethash;
          _this.commits = null;
        }
        callback(meta);
      };
      queryNetworkMeta(this.login, this.repo, sinkMeta, function() {
        return typeof _this.error === "function" ? _this.error() : void 0;
      });
    };

    Network.prototype.eachCommit = function(commit, success) {
      var d, _i, _len, _ref,
        _this = this;
      if (this.commits != null) {
        _ref = this.commits.slice(0).reverse();
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          d = _ref[_i];
          commit(d);
        }
        success();
      } else {
        this.getMeta(function(meta) {
          var focus, nCommits, nethash, queryRest, sinkData, totalCommits;
          nCommits = 0;
          totalCommits = meta.dates.length;
          nethash = meta.nethash;
          focus = totalCommits - 1;
          queryRest = function() {
            var end, start;
            start = focus > 99 ? focus - 99 : 0;
            end = focus;
            focus = start - 1;
            queryNetworkData(_this.login, _this.repo, nethash, start, end, sinkData, function() {
              return typeof _this.error === "function" ? _this.error() : void 0;
            });
          };
          sinkData = function(data) {
            var commits, _j, _len1, _ref1, _ref2;
            commits = data.commits;
            if (typeof _this.status === "function") {
              _this.status({
                type: "commit",
                n: nCommits += commits.length,
                total: totalCommits
              });
            }
            _ref1 = commits.slice(0).reverse();
            for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
              d = _ref1[_j];
              commit(((_ref2 = _this.commits) != null ? _ref2 : _this.commits = [])[d.time] = d);
            }
            if (!(focus < 0)) {
              queryRest();
            } else {
              success();
            }
          };
          queryRest();
        });
      }
    };

    return Network;

  })();

}).call(this);
